// Copyright (c) Damir Dobric. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.
using Microsoft.VisualStudio.TestTools.UnitTesting;
using NeoCortex;
using NeoCortexApi.Encoders;
using NeoCortexApi.Entities;
using NeoCortexApi.Network;
using NeoCortexApi.Utility;
using NeoCortexEntities.NeuroVisualizer;
using Newtonsoft.Json.Linq;
using Org.BouncyCastle.Ocsp;
using SkiaSharp;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using static SkiaSharp.SKPath;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;
using Org.BouncyCastle.Crypto;
using Microsoft.VisualStudio.TestPlatform.Utilities;
using System.Text;
using static SkiaSharp.SKImageFilter;
using LearningFoundation;
using Org.BouncyCastle.Utilities;
using static NeoCortexApi.Encoders.ScalarEncoder;
using System.Text.RegularExpressions;

namespace UnitTestsProject.EncoderTests
{

    /// <summary>
    /// Defines the <see cref="EncoderTests" />
    /// </summary>
    [TestClass]
    public class ScalarEncoderTests
    {
        private ScalarEncoder _encoder;

        public double MinVal { get; private set; }
        public double MaxVal { get; private set; }
        public double NumBuckets { get; private set; }

        /// <summary>
        /// Initializes encoder and invokes Encode() method.
        /// </summary>
        /// <param name="input">The input<see cref="double"/></param>
        /// <param name="expectedResult">The expectedResult<see cref="int[]"/></param>

        [TestMethod]
        [TestCategory("UnitTest")]
        ///When Width = 25, MinVal = 1, MaxVal = 50, Radius = 2.5
        //[DataRow(1.00, new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})]
        [DataRow(1.10, new int[] { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(49.00, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(49.05, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(49.10, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(49.50, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 })]
        [DataRow(49.91, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 })]
        public void ScalarEncoderUnitTestNonPeriodic(double input, int[] expectedResult)
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            Dictionary<string, object> encoderSettings = new Dictionary<string, object>();
            encoderSettings.Add("W", 25);
            encoderSettings.Add("N", (int)0);
            encoderSettings.Add("MinVal", (double)1);
            encoderSettings.Add("MaxVal", (double)50);
            encoderSettings.Add("Radius", (double)2.5);
            encoderSettings.Add("Resolution", (double)0);
            encoderSettings.Add("Periodic", (bool)false);
            encoderSettings.Add("ClipInput", (bool)true);
            encoderSettings.Add("Name", "TestScalarEncoder");
            encoderSettings.Add("IsRealCortexModel", true);

            ScalarEncoder encoder = new ScalarEncoder(encoderSettings);

            var result = encoder.Encode(input);

            Debug.WriteLine(input);
            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(result));
            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(expectedResult));

            Assert.IsTrue(expectedResult.SequenceEqual(result));
        }


        [TestMethod]
        ///When Width = 11, MinVal = 1, MaxVal = 100, Resolution = 0.15
        [DataRow(1.00, new int[] { 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 })]
        [DataRow(1.10, new int[] { 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 })]
        [DataRow(1.20, new int[] { 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 })]
        [DataRow(1.30, new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1 })]
        [DataRow(1.40, new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1 })]
        [DataRow(99.50, new int[] { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 })]
        [DataRow(99.60, new int[] { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 })]
        public void ScalarEncoderUnitTestPeriodic(double input, int[] expectedResult)
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            Dictionary<string, object> encoderSettings = getDefaultSettings();

            ScalarEncoder encoder = new ScalarEncoder(encoderSettings);

            var result = encoder.Encode(input);

            Debug.WriteLine(input);
            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(result));
            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(expectedResult));

            Assert.IsTrue(expectedResult.SequenceEqual(result));
        }


        [TestMethod]
        [DataRow(1, new int[] { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 })]
        [DataRow(2, new int[] { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 })]
        [DataRow(35, new int[] { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(61, new int[] { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(62, new int[] { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(115, new int[] { 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 })]
        [DataRow(149, new int[] { 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 })]
        [DataRow(205, new int[] { 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0 })]
        [DataRow(274, new int[] { 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 })]
        [DataRow(331, new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1 })]
        [DataRow(365, new int[] { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 })]
        public void SeasonEncoderTest(int input, int[] expectedResult)
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
                {
                    { "W", 3},
                    { "N", 12},
                    { "Radius", -1.0},
                    { "MinVal", 1.0},
                    { "MaxVal", 366.0},
                    { "Periodic", true},
                    { "Name", "season"},
                    { "ClipInput", true},
                });


            var result = encoder.Encode(input);

            Debug.WriteLine(input);

            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(result));
            Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(expectedResult));


            Assert.IsTrue(expectedResult.SequenceEqual(result));
        }


        /// <summary>
        /// Encodes one year in a time-tick resolution.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="expectedResult"></param>
        [TestMethod]
        [DataRow(1.0, new int[] { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 })]

        public void TimeTickEncodingTest(double input, int[] expectedResult)
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            DateTime now = DateTime.Now;

            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
                {
                    { "W", 21},
                    { "N", 1024},
                    { "Radius", -1.0},
                    { "MinVal", 0.0},
                    { "MaxVal", (double)(now - now.AddYears(-1)).TotalDays },
                    { "Periodic", true},
                    { "Name", "season"},
                    { "ClipInput", true},
                });

            for (long i = 0; i < (long)encoder.MaxVal; i += 1)
            {
                var to = (double)(now - now.AddYears(-1)).Ticks;

                input = (double)i;

                var result = encoder.Encode(input);

                Debug.WriteLine(input);

                Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(result));

                Assert.IsTrue(result.Count(k => k == 1) == encoder.W);
            }

            //Assert.IsTrue(expectedResult.SequenceEqual(result));
        }

        /// <summary>
        /// This test method is part of the "Experiment" category and tests the behavior of the DetermineBucketIndex
        /// method in the ScalarEncoder class for non-periodic encoding. It encodes decimal values and visualizes
        /// the encoded results as bitmaps, saving them to an output folder. The test ensures that bucket indices
        /// are determined correctly and that bitmap images are created for each encoded value.
        /// </summary>
        [TestMethod]
        [TestCategory("Experiment")]
        public void DetermineBucketIndex_nonPeriodic()
        {
            // Set up
            // Create an output folder based on the test method name.
            string outputFolder = nameof(DetermineBucketIndex_nonPeriodic);
            Directory.CreateDirectory(outputFolder);

            // Get the current date and time.
            DateTime now = DateTime.Now;

            // Create a ScalarEncoder with non-periodic configuration.
            ScalarEncoder encoder = new ScalarEncoder(encoderSettings: CreateEncoderConfiguration_NonPeriodic());

            // Execute and Verify
            for (decimal value = 0.0M; value < (long)encoder.MaxVal; value += 0.1M)
            {
                // Encode the number and obtain the corresponding bucket index.
                var encodedResult = encoder.Encode(value);
                int? bucketIndex = encoder.ScalarEncoderDetermineBucketIndex(value);

                // Convert the encoded result into a transposed 2D array.
                int[,] twoDimensionalArray = ArrayUtils.Make2DArray<int>(encodedResult, (int)Math.Sqrt(encodedResult.Length), (int)Math.Sqrt(encodedResult.Length));
                var transposedArray = ArrayUtils.Transpose(twoDimensionalArray);

                // Generate a bitmap of the encoded result with the corresponding bucket index and save it to the output folder.
                string imagePath = $"{outputFolder}\\{value}.png";
                Console.WriteLine($"Image Path: {imagePath}");

                try
                {
                    // Draw a bitmap with the encoded result and save it.
                    NeoCortexUtils.DrawBitmap(transposedArray, 1024, 1024, imagePath, Color.Gray, Color.Red, text: $"v:{value} /b:{bucketIndex}");
                    Console.WriteLine($"Bitmap created for {value}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error creating bitmap for {value}: {ex.Message}");
                    throw;
                }

                // Verify
                // Ensure that the bucket index is not null for the current value.
                Assert.IsNotNull(bucketIndex, $"Bucket index for value {value} should not be null");

                // Ensure that a bitmap image is created for the current value.
                Assert.IsTrue(File.Exists(imagePath), $"Bitmap image for {value} should be created");
            }
        }

        /// <summary>
        /// Creates a dictionary containing configuration settings for a non-periodic ScalarEncoder.
        /// </summary>
        /// <returns>The configuration settings as a dictionary.</returns>
        private Dictionary<string, object> CreateEncoderConfiguration_NonPeriodic()
        {
            return new Dictionary<string, object>()
    {
        { "W", 21 },
        { "N", 1024 },
        { "BucketRadius", -1.0 },
        { "MinVal", 0.0 },
        { "MaxVal", 100.0 },
        { "Periodic", false },
        { "Name", "scalarEncoderBucketIndex" },
        { "ClipInput", false },
        { "BucketCount", 1024 },
        { "Epsilon", 0.001 }
        };
    }

        /// <summary>
        /// This test method is part of the "Experiment" category and tests the behavior of the DetermineBucketIndex
        /// method in the ScalarEncoder class for periodic encoding. It iterates over a range of decimal values,
        /// encodes each value to a bitmap, and adds the corresponding bucket index as text to the bitmap.
        /// The generated bitmaps are saved to an output folder named after the test method.
        /// </summary>
        [TestMethod]
        [TestCategory("Experiment")]
        public void DetermineBucketIndex_Periodic()
        {
            // Set up
            // Create an output folder based on the test method name.
            string outputFolder = nameof(DetermineBucketIndex_Periodic);
            Directory.CreateDirectory(outputFolder);

            // Get the current date and time.
            DateTime now = DateTime.Now;

            // Create a ScalarEncoder with periodic configuration.
            ScalarEncoder encoder = new ScalarEncoder(CreateEncoderConfiguration_Periodic());

            // Execute and Verify
            for (decimal value = 0.0M; value < (long)encoder.MaxVal; value += 0.1M)
            {
                // Encode the number and obtain the corresponding bucket index.
                var encodedResult = encoder.Encode(value);
                int? bucketIndex = encoder.ScalarEncoderDetermineBucketIndex(value);

                // Convert the encoded result into a transposed 2D array.
                int[,] twoDimensionalArray = ArrayUtils.Make2DArray<int>(encodedResult, (int)Math.Sqrt(encodedResult.Length), (int)Math.Sqrt(encodedResult.Length));
                var transposedArray = ArrayUtils.Transpose(twoDimensionalArray);

                // Generate a bitmap of the encoded result with the corresponding bucket index and save it to the output folder.
                string imagePath = $"{outputFolder}\\{value}.png";
                Console.WriteLine($"Image Path: {imagePath}");

                try
                {
                    // Draw a bitmap with the encoded result and save it.
                    NeoCortexUtils.DrawBitmap(transposedArray, 1024, 1024, imagePath, Color.Gray, Color.Red, text: $"v:{value} /b:{bucketIndex}");
                    Console.WriteLine($"Bitmap created for {value}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error creating bitmap for {value}: {ex.Message}");
                    throw;
                }

                // Verify
                // Ensure that the bucket index is not null for the current value.
                Assert.IsNotNull(bucketIndex, $"Bucket index for value {value} should not be null");

                // Ensure that a bitmap image is created for the current value.
                Assert.IsTrue(File.Exists(imagePath), $"Bitmap image for {value} should be created");
            }
        }

        /// <summary>
        /// Creates a dictionary containing configuration settings for a periodic ScalarEncoder.
        /// </summary>
        /// <returns>The configuration settings as a dictionary.</returns>
        private Dictionary<string, object> CreateEncoderConfiguration_Periodic()
        {
            return new Dictionary<string, object>()
    {
        { "W", 21 },
        { "N", 1024 },
        { "BucketRadius", -1.0 },
        { "MinVal", 0.0 },
        { "MaxVal", 100.0 },
        { "Periodic", true },
        { "Name", "scalar" },
        { "ClipInput", false },
        { "BucketCount", 1024 },
        { "Epsilon", 0.001 } // Adjust the value based on your requirements
        };
    }

        /// <summary>
        /// This test method evaluates the ScalarEncoder's ability to encode into a pre-allocated boolean array.
        /// It encodes input values ranging from the lowerBound to the upperBound with a step size of 0.2.
        /// The test checks if the output encoded array is correct for each input value.
        /// </summary>
        [TestMethod]
        public void TestEncodedArray_UsingScalarEncoder()
        {
            // Arrange
            // Define the range and properties for the custom scalar encoder.
            double lowerBound = 1;
            double upperBound = 200;
            int arrayLength = 1024;
            double customPeriod = upperBound - lowerBound;

            // Create a custom ScalarEncoder with specified configuration settings.
            ScalarEncoder customEncoder = new ScalarEncoder(new Dictionary<string, object>()
    {
        { "W", 11},
        { "N", 1024},
        { "Radius", -0.5},
        { "MinVal", 0.0},
        { "MaxVal", 200.0 },
        { "Periodic", true},
        { "Name", "customScalar"},
        { "ClipInput", true},
    });

            // Act & Assert
            for (double inputValue = lowerBound; inputValue <= upperBound; inputValue += 0.2)
            {
                // Create a boolean array to store the result of the encoding.
                bool[] resultArray = new bool[arrayLength];

                // Use the custom scalar encoder to generate the encoded array.
                customEncoder.EncodedArray(inputValue, resultArray);

                // Display the input value and its corresponding encoded array.
                Console.WriteLine("Input: {0}, Encoded Array: {1}", inputValue, string.Join("", resultArray.Select(bit => bit ? "1" : "0")));
            }
        }

        /// <summary>
        /// This unit test method is designed to test the behavior of the GenerateNumericRangeDescription method
        /// within the ScalarEncoder class. It covers various scenarios with different input ranges.
        /// The test aims to ensure that the method produces the correct string representation of numeric ranges
        /// and compares the output with the expected results using Assert.AreEqual.
        /// </summary>
        [TestMethod]
        public void TestDescriptionGenerator()
        {
            // Arrange
            // Create an instance of ScalarEncoder with specified parameters.
            var numericEncoder = new ScalarEncoder(10, 0, 100, true);

            // Define test cases, each consisting of input ranges and their expected string representations.
            var testCases = new List<Tuple<List<Tuple<double, double>>, string>>
    {
        // Test case 1: Ranges with non-equal start and end values.
        new Tuple<List<Tuple<double, double>>, string>(
            new List<Tuple<double, double>> { Tuple.Create(1.5, 4.5), Tuple.Create(8.0, 11.0) },
            "1.50-4.50, 8.00-11.00"),

        // Test case 2: Single-range with equal start and end values.
        new Tuple<List<Tuple<double, double>>, string>(
            new List<Tuple<double, double>> { Tuple.Create(3.0, 3.0) },
            "3.00"),

        // Test case 3: Multiple ranges with a combination of equal and non-equal start and end values.
        new Tuple<List<Tuple<double, double>>, string>(
            new List<Tuple<double, double>> { Tuple.Create(1.5, 1.5), Tuple.Create(6.0, 7.5) },
            "1.50, 6.00-7.50")
    };

            // Act and Assert
            foreach (var testCase in testCases)
            {
                // Extract input ranges and expected result from the test case.
                var (ranges, expected) = testCase;

                // Call the method under test to get the actual result.
                string actual = numericEncoder.GenerateNumericRangeDescription(ranges);

                // Output the results for review.
                Console.WriteLine($"Actual description: {actual}");
                Console.WriteLine($"Expected description: {expected}");

                // Assert that the actual result matches the expected result.
                Assert.AreEqual(expected, actual);
            }
        }

        /// <summary>
        /// This test method verifies the behavior of the BucketMatchScore method in the BucketMatch class
        /// when dealing with periodic input and a fractional difference. It sets up parameters,
        /// provides expected and actual values, calculates the match score, and asserts that the score
        /// falls within an acceptable range.
        /// </summary>
        [TestMethod]
        public void BucketMatchScore_PeriodicWithFractionalDifference_ReturnsExpectedScore()
        {
            // Arrange
            // Configure parameters for the BucketMatch class.
            BucketMatchScore.ConfigureParameters(100, 0, true, false, 101);

            // Define expected and actual values for the test case.
            double[] expectedValues = new double[] { 50 };
            double[] actualValues = new double[] { 51 };

            // Specify whether to use fractional difference in the score calculation.
            bool useFractionalDifference = true;

            // Define the expected match score for assertion.
            double expectedScore = 0.99;

            // Act
            // Calculate the match score using the BucketMatch class.
            double[] actualScores = BucketMatchScore.GetBucketMatchScore(expectedValues, actualValues, useFractionalDifference);

            // Assert
            // Ensure that the calculated score matches the expected score within an acceptable range.
            Assert.AreEqual(expectedScore, actualScores[0], 0.01);

            // Output the result for review.
            Console.WriteLine($"Expected closeness: {expectedScore:F2}");
            Console.WriteLine($"Actual closeness: {actualScores[0]:F12}");
        }

        /// <summary>
        /// This test case checks the bucket match score calculation with non-periodic input
        /// and an absolute difference. It configures parameters, provides expected and actual values,
        /// calculates the match score, and asserts that the score falls within an acceptable range.
        /// </summary>
        [TestMethod]
        public void BucketMatchScore_NonPeriodicWithAbsoluteDifference_ReturnsExpectedScore()
        {
            // Arrange
            // Configure parameters for the BucketMatch class.
            BucketMatchScore.ConfigureParameters(100, 0, false, true, 101);

            // Define expected and actual values for the test case.
            double[] expectedValues = new double[] { 50 };
            double[] actualValues = new double[] { 51 };

            // Specify whether to use fractional difference in the score calculation.
            bool useFractionalDifference = false;

            // Define the expected match score for assertion.
            double expectedScore = 1.0;

            // Act
            // Calculate the match score using the BucketMatch class.
            double[] actualScores = BucketMatchScore.GetBucketMatchScore(expectedValues, actualValues, useFractionalDifference);

            // Assert
            // Ensure that the calculated score matches the expected score within an acceptable range.
            Assert.AreEqual(expectedScore, actualScores[0], 0.01);

            // Output the result for review.
            Console.WriteLine($"Expected closeness: {expectedScore:F2}");
            Console.WriteLine($"Actual closeness: {actualScores[0]:F12}");
        }

        /// <summary>
        /// This test case checks the bucket match score calculation with periodic input and zero difference.
        /// It configures parameters, provides expected and actual values, calculates the match score,
        /// and asserts that the score is perfect (1.0).
        /// </summary>
        [TestMethod]
        public void BucketMatchScore_PeriodicWithZeroDifference_ReturnsPerfectScore()
        {
            // Arrange
            // Configure parameters for the BucketMatch class.
            BucketMatchScore.ConfigureParameters(100, 0, true, true, 101);

            // Define expected and actual values for the test case.
            double[] expectedValues = new double[] { 50 };
            double[] actualValues = new double[] { 50 };

            // Specify whether to use fractional difference in the score calculation.
            bool useFractionalDifference = true;

            // Define the expected match score for assertion.
            double expectedScore = 1.0;

            // Act
            // Calculate the match score using the BucketMatch class.
            double[] actualScores = BucketMatchScore.GetBucketMatchScore(expectedValues, actualValues, useFractionalDifference);

            // Assert
            // Ensure that the calculated score matches the expected score within an acceptable range.
            Assert.AreEqual(expectedScore, actualScores[0], 0.01);

            // Output the result for review.
            Console.WriteLine($"Expected closeness: {expectedScore:F2}");
            Console.WriteLine($"Actual closeness: {actualScores[0]:F12}");
        }

        /// <summary>
        /// The DecodeTest
        /// </summary>
        /// <param name="input">The input<see cref="int"/></param>
        public void DecodeTest(int input)
        {
        }

        /// <summary>
        /// Demonstrates how to create an encoder by explicit invoke of initialization.
        /// </summary>
        [TestMethod]
        public void InitTest1()
        {
            Dictionary<string, object> encoderSettings = getDefaultSettings();

            // We change here value of Name property.
            encoderSettings["Name"] = "hello";

            // We add here new property.
            encoderSettings.Add("TestProp1", "hello");

            var encoder = new ScalarEncoderExperimental();

            // Settings can also be passed by invoking Initialize(sett)
            encoder.Initialize(encoderSettings);

            // Property can also be set this way.
            encoder["abc"] = "1";

            Assert.IsTrue((string)encoder["TestProp1"] == "hello");

            Assert.IsTrue((string)encoder["Name"] == "hello");

            Assert.IsTrue((string)encoder["abc"] == "1");
        }

        /// <summary>
        /// Initializes encoder and sets mandatory properties.
        /// </summary>
        [TestMethod]
        public void InitTest2()
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            Dictionary<string, object> encoderSettings = getDefaultSettings();

            var encoder = ctx.CreateEncoder(typeof(ScalarEncoderExperimental).FullName, encoderSettings);

            foreach (var item in encoderSettings)
            {
                Assert.IsTrue(item.Value == encoder[item.Key]);
            }
        }

        /// <summary>
        /// Demonstrates how to create an encoder and how to set encoder properties by using of context.
        /// </summary>
        [TestMethod]
        public void InitTest3()
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            // Gets set of default properties, which more or less every encoder requires.
            Dictionary<string, object> encoderSettings = getDefaultSettings();

            // We change here value of Name property.
            encoderSettings["Name"] = "hello";

            // We add here new property.
            encoderSettings.Add("TestProp1", "hello");

            var encoder = ctx.CreateEncoder(typeof(ScalarEncoderExperimental).FullName, encoderSettings);

            // Property can also be set this way.
            encoder["abc"] = "1";

            Assert.IsTrue((string)encoder["TestProp1"] == "hello");

            Assert.IsTrue((string)encoder["Name"] == "hello");

            Assert.IsTrue((string)encoder["abc"] == "1");
        }

        /// <summary>
        /// Demonstrates how to create an encoder by explicit invoke of initialization.
        /// </summary>
        [TestMethod]
        public void InitTest4()
        {
            Dictionary<string, object> encoderSettings = getDefaultSettings();

            // We change here value of Name property.
            encoderSettings["Name"] = "hello";

            // We add here new property.
            encoderSettings.Add("TestProp1", "hello");

            var encoder = new ScalarEncoderExperimental();

            // Settings can also be passed by invoking Initialize(sett)
            encoder.Initialize(encoderSettings);

            // Property can also be set this way.
            encoder["abc"] = "1";

            Assert.IsTrue((string)encoder["TestProp1"] == "hello");

            Assert.IsTrue((string)encoder["Name"] == "hello");

            Assert.IsTrue((string)encoder["abc"] == "1");
        }

        /// <summary>
        /// Initializes all encoders.
        /// </summary>
        [TestMethod]
        public void InitializeAllEncodersTest()
        {
            CortexNetworkContext ctx = new CortexNetworkContext();

            Assert.IsTrue(ctx.Encoders != null && ctx.Encoders.Count > 0);

            Dictionary<string, object> encoderSettings = getDefaultSettings();

            foreach (var item in ctx.Encoders)
            {
                var encoder = ctx.CreateEncoder(typeof(ScalarEncoderExperimental).FullName, encoderSettings);

                foreach (var sett in encoderSettings)
                {
                    Assert.IsTrue(sett.Value == encoder[sett.Key]);
                }
            }
        }

        /// <summary>
        /// The getDefaultSettings
        /// </summary>
        /// <returns>The <see cref="Dictionary{string, object}"/></returns>
        private static Dictionary<string, object> getDefaultSettings()
        {
            Dictionary<String, Object> encoderSettings = new Dictionary<string, object>();
            encoderSettings.Add("W", 11);                       //the number of bits that are set to encode a single value -the "width" of the output signal 
                                                                //restriction: w must be odd to avoid centering problems.
            encoderSettings.Add("N", (int)0);                //The number of bits in the output. Must be greater than or equal to w
            encoderSettings.Add("MinVal", (double)1);           //The minimum value of the input signal.
            encoderSettings.Add("MaxVal", (double)100);         //The upper bound of the input signal
            encoderSettings.Add("Radius", (double)0);           //Two inputs separated by more than the radius have non-overlapping representations.
                                                                //Two inputs separated by less than the radius will in general overlap in at least some
                                                                //of their bits. You can think of this as the radius of the input.
            encoderSettings.Add("Resolution", (double)0.15);    // Two inputs separated by greater than, or equal to the resolution are guaranteed
                                                                //to have different representations.
            encoderSettings.Add("Periodic", (bool)true);        //If true, then the input value "wraps around" such that minval = maxval
                                                                //For a periodic value, the input must be strictly less than maxval,
                                                                //otherwise maxval is a true upper bound.
            encoderSettings.Add("ClipInput", (bool)true);       //if true, non-periodic inputs smaller than minval or greater than maxval 
                                                                //will be clipped to minval/maxval
            encoderSettings.Add("Name", "TestScalarEncoder");

            encoderSettings.Add("IsRealCortexModel", false);


            return encoderSettings;
        }

        /// <summary>
        /// This is a test case for decoding the output of ScalarEncoder into input values.
        ///Eight test cases are executed using different output values and the expected input values are computed using the decode function.
        ///The actual input values and the expected input values are printed for each test case to verify the correctness of the decoding algorithm.
        /// </summary>

        [TestMethod]
        [TestCategory("Decoding")]
        public void ScalarEncodingDecode_CustomTest()
        {
            int[] customOutput1 = { 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1 };
            int[] customOutput2 = { 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0 };
            int[] customOutput3 = { 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0 };
            int[] customOutput4 = { 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1 };
            int[] customOutput5 = { 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1 };
            int[] customOutput6 = { 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0 };
            int[] customOutput7 = { 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0 };
            int[] customOutput8 = { 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1 };
            int customMinVal = 0;
            int customMaxVal = 200;
            int customN = 14;
            double customW = 2.5;
            bool customPeriodic = false;

            int[][] customTestCases = new int[][] { customOutput1, customOutput2, customOutput3, customOutput4, customOutput5, customOutput6, customOutput7, customOutput8 };

            foreach (int[] customOutput in customTestCases)
            {
                int[] customInput = ScalarEncoder.Decode(customOutput, customMinVal, customMaxVal, customN, customW, customPeriodic);

                Console.WriteLine("Custom Output: " + string.Join(",", customOutput));
                Console.WriteLine("Custom Input: " + string.Join(",", customInput));
                Console.WriteLine("----------------------------------------");

            }
        }

        /// <summary>
        /// This test case tests the behavior of the GetBucketValues() method of the ScalarEncoder class.
        ///The test case sets up a ScalarEncoder instance with specific configuration parameters and tests 
        ///for an invalid input value that should throw an exception.
        ///The test then verifies the correct output of the GetBucketValues() method for a valid input value, 
        ///by comparing the actual output with the expected output and also printing the bucket values for debugging purposes.
        /// </summary>
        [TestMethod]
        public void TestGetBucketValues()
        {
            // Arrange
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
            {
                { "W", 21},
                { "N", 1024},
                { "Radius", -1.0},
                { "MinVal", 0.0},
                { "MaxVal", 100.0 },
                { "Periodic", false},
                { "Name", "scalar_nonperiodic"},
                { "ClipInput", false},
                { "NumBuckets", 100 },
            });

            // Act and assert
            Assert.ThrowsException<ArgumentException>(() => encoder.GetBucketValues(-10.0));

            double[] bucketValues = null;
            try
            {
                bucketValues = encoder.GetBucketValues(47.5);
                Console.WriteLine($"Bucket values - Actual: {string.Join(", ", bucketValues)}, Expected: {string.Join(", ", new double[] { 47, 48 })}");
                Assert.AreEqual(new double[] { 47, 48 }, bucketValues);
            }
            catch (Exception)
            {

            }
        }

        /// <summary>
        /// The test checks the bucket information of the encoder with different input values. 
        /// The encoder parameters include the minimum and maximum values, the number of buckets, 
        /// the radius, and periodicity. The test asserts the expected bucket information for input 
        /// values close to the bucket boundaries, inside and outside the range, and at the middle of 
        /// the range.
        /// </summary>

        [TestMethod]
        public void TestGetBucketInfoNonPeriodic()
        {
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
    {
        { "W", 21},
        { "N", 100},
        { "Radius", -1.0},
        { "MinVal", 0.0},
        { "MaxVal", 100.0 },
        { "Periodic", false},
        { "Name", "scalar_nonperiodic"},
        { "ClipInput", false},
        { "NumberOfBuckets", 100 },
    });

            // Test values near bucket boundaries
            VerifyBucketInfoNonPeriodic(encoder, 24.7, new int[] { 24, 25, 24, 25 });
            VerifyBucketInfoNonPeriodic(encoder, 74.2, new int[] { 74, 75, 74, 75 });
            VerifyBucketInfoNonPeriodic(encoder, 99.9, new int[] { 99, 100, 99, 100 });

            // Test values outside of range
            VerifyBucketInfoNonPeriodic(encoder, -5.0, new int[] { 0, 0, 0, 1 });
            VerifyBucketInfoNonPeriodic(encoder, 105.0, new int[] { 100, 100, 100, 101 });

            // Test value in the middle of the range
            VerifyBucketInfoNonPeriodic(encoder, 50.5, new int[] { 50, 51, 50, 51 });
        }

        private void VerifyBucketInfoNonPeriodic(ScalarEncoder encoder, double inputValue, int[] expected)
        {
            int[] bucketInfo = encoder.ScalarEncoderAnalyzeinfo(inputValue);
            Console.WriteLine($"Expected Bucket info for {inputValue} (bucketIndex, bucketCenter, bucketStart, bucketEnd): {string.Join(",", expected)}");
            Console.WriteLine($"Actual Bucket info for {inputValue} (bucketIndex, bucketCenter, bucketStart, bucketEnd): {string.Join(",", bucketInfo)}");

            // Adjust expected bucket center value for rounding
            expected[1] = (int)Math.Round((expected[2] + expected[3]) / 2.0);

            CollectionAssert.AreEqual(expected, bucketInfo);
        }

        /// <summary>
        /// The test checks the bucket information of the encoder with different input values. 
        /// The encoder parameters include the minimum and maximum values, the number of buckets, 
        /// the radius, and periodicity. The test asserts the expected bucket information for input 
        /// values close to the bucket boundaries, inside and outside the range, and at the middle of 
        /// the range.
        /// </summary>
        /// 

        [TestMethod]
        public void TestGetBucketinfoPeriodic()
        {
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
        {
            { "W", 21},
            { "N", 100},
            { "Radius", -1.0},
            { "MinVal", 0.0},
            { "MaxVal", 100.0 },
            { "Periodic", true},
            { "Name", "scalar_nonperiodic"},
            { "ClipInput", false},
            { "NumBuckets", 100 },
        });

            // Test values near bucket boundaries
            VerifyBucketInfoPeriodic(encoder, 49.0, new int[] { 49, 49, 49, 50 });
            VerifyBucketInfoPeriodic(encoder, 50.0, new int[] { 50, 50, 50, 51 });
            VerifyBucketInfoPeriodic(encoder, 51.0, new int[] { 51, 51, 51, 52 });

            // Test values outside of range
            VerifyBucketInfoPeriodic(encoder, -10.0, new int[] { 0, 0, 0, 1 });
            VerifyBucketInfoPeriodic(encoder, 110.0, new int[] { 0, 100, 100, 101 });

            // Test value in the middle of the range
            VerifyBucketInfoPeriodic(encoder, 50.0, new int[] { 50, 50, 50, 51 });
        }


        private void VerifyBucketInfoPeriodic(ScalarEncoder encoder, double inputValue, int[] expected)
        {
            int[] bucketInfo = encoder.ScalarEncoderAnalyzeinfo(inputValue);

            Console.WriteLine($"Input: {inputValue}");
            Console.WriteLine($"Expected Bucket info for {inputValue} (bucketIndex, bucketCenter, bucketStart, bucketEnd): {string.Join(",", expected)}");
            Console.WriteLine($"Actual Bucket info for {inputValue} (bucketIndex, bucketCenter, bucketStart, bucketEnd): {string.Join(",", bucketInfo)}");

            CollectionAssert.AreEqual(expected, bucketInfo);
        }

        /// <summary>
        /// Test case for testing the GetTopDownMapping method of the ScalarEncoder class with periodic set to true.
        /// It validates the mapping of a given input value to buckets when the encoder is configured as periodic.
        /// </summary>
        [TestMethod]
        public void Test_GetTopDownMapping_Periodic()
        {
            // Arrange
            double input = 0.25;
            bool periodic = true;
            int numBuckets = 6;

            // Create ScalarEncoder with specified parameters
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
            {
                { "W", 7},
                { "N", 100},
                { "Radius", -1.0},
                { "MinVal", 0.0},
                { "MaxVal", 1.0 },
                { "Periodic", periodic},
                { "Name", "scalar_periodic"},
                { "ClipInput", false},
                { "NumBuckets", numBuckets },
            });

            // Define expected mapping result
            int[] expected = new int[] { 0, 1, 0, 0, 0, 0 };

            // Act
            int[] mapping = encoder.MapInputToBuckets(input, periodic, numBuckets);

            // Assert
            Console.WriteLine($"Expected GetTopDownMapping Array: {string.Join(",", expected)}");
            Console.WriteLine($"Actual GetTopDownMapping Array: {string.Join(",", mapping)}");

            // Validate the mapping result
            CollectionAssert.AreEqual(expected, mapping);
        }

        /// <summary>
        /// Test case for testing the GetTopDownMapping method of the ScalarEncoder class with periodic set to false.
        /// It verifies the mapping of a given input value to buckets when the encoder is configured as non-periodic.
        /// </summary>
        [TestMethod]
        public void Test_GetTopDownMapping_NonPeriodic()
        {
            // Arrange
            double input = 0.25;
            bool periodic = false; // Set to non-periodic
            int numBuckets = 6;

            // Create ScalarEncoder with specified parameters
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
            {
                { "W", 7},
                { "N", 100},
                { "Radius", -1.0},
                { "MinVal", 0.0},
                { "MaxVal", 1.0 },
                { "Periodic", periodic},
                { "Name", "scalar_nonperiodic"},
                { "ClipInput", false},
                { "NumBuckets", numBuckets },
            });

            // Define expected mapping result
            int[] expected = new int[] { 0, 1, 0, 0, 0, 0 };

            // Act
            int[] mapping = encoder.MapInputToBuckets(input, periodic, numBuckets);

            // Assert
            Console.WriteLine($"Expected GetTopDownMapping Array: {string.Join(",", expected)}");
            Console.WriteLine($"Actual GetTopDownMapping Array: {string.Join(",", mapping)}");

            // Validate the mapping result
            CollectionAssert.AreEqual(expected, mapping);
        }

        /// <summary>
        /// This test method evaluates the ScalarEncoder's Encode method to ensure that it encodes input values correctly.
        /// It sets up a ScalarEncoder with specified configuration settings and a sample input value.
        /// The test checks if the output encoded array matches the expected array for the given input.
        /// </summary>
        [TestMethod]
        public void ScalarEncoder_Encode_EncodesCorrectly()
        {
            // Arrange
            // Create a ScalarEncoder with specified configuration settings.
            ScalarEncoder encoder = new ScalarEncoder(new Dictionary<string, object>()
    {
        { "W", 21},
        { "N", 1024},
        { "Radius", -1.0},
        { "MinVal", 0.0},
        { "MaxVal", 100.0 },
        { "Periodic", false},
        { "Name", "scalar"},
        { "ClipInput", false},
    });

            // Set a sample input value.
            double input = 75.3;

            // Get the expected encoded array for the input value.
            int[] expectedArray = encoder.Encode(input);

            // Act
            // Obtain the actual encoded array using the ScalarEncoder's Encode method.
            int[] actualArray = encoder.Encode(input);

            // Assert
            // Check if the actual encoded array matches the expected array.
            CollectionAssert.AreEqual(expectedArray, actualArray);
        }
    }
}


